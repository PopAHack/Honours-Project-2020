package sample;

import javafx.scene.paint.Color;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.Matrix;


import java.nio.file.FileSystemNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;


public class DistanceDataCollector {

    // Global vars.
    private List<CityNode> listOfCities = new ArrayList<>();
    private List<CityNode> m_EffDis = new ArrayList<>();
    private static Matrix effDisMatrix;
    private static Matrix travelMatrix;
    private int seed = 0;

    // Constructor.
    public DistanceDataCollector() {
        try {
            // Populate Matrices.
            // TODO This is where the flight API would be called, and flights calculated and filtered.
            // For now, we will randomly generate the data from a normal distribution.

            // Generate travel matrix.
            Random rand = new Random(seed);
            int numCities = 1000; // This is an estimate of the number of cities we will have.  Will be generated by the actual number of cities later on.

            effDisMatrix = new DenseMatrix(numCities, numCities);
            travelMatrix = new DenseMatrix(numCities, numCities);

            // Generate the travel list with each city object
            for (int i = 0; i < numCities; i++) {
                listOfCities.add(i, new CityNode(String.valueOf(i), i,(int)(rand.nextInt(60) + 0.8)*1000000)); // cityPop: max 68 mil, min: 800,000
            }

            // Choose center target city and set graphics
            CityNode.setCenterTarget(listOfCities.get(0));
            CityNode.getCenterTarget().setPaint(Color.valueOf("#F24C27"));
            CityNode.getCenterTarget().setSize(20);

            // Give each city a travelers from center city value
            for(int i = 0; i < numCities; i++) // rows
            {
                for(int j = 0; j < numCities; j++) // columns
                {
                    if(i==j) // No one travels from their city to their city
                    {
                        travelMatrix.set(i,j, 0); // Also stops center city from being drawn twice;
                    }
                    else
                    {
                        double travelers = ((int) (rand.nextGaussian() * 2 + 3) * ((int) (rand.nextGaussian() * 50 + 140))); // Average number of flights per day, multiplied by avg passengers (per day)
                        travelMatrix.set(i,j,travelers);
                    }
                }
            }

            // Generate EffDis matrix
            for (int i = 0; i < numCities; i++) { // Rows
                for (int j = 0; j < numCities; j++) { // Columns
                    // Get flux fraction from city I to city J
                    double fluxFraction = travelMatrix.get(i,j) / listOfCities.get(j).getCityPopulation();
                    if (fluxFraction == 0 || fluxFraction < 0 || Double.isInfinite(fluxFraction) || Double.isNaN(fluxFraction)) {
                        effDisMatrix.set(i,j,-1); // < 0 implies infinite distance
                        continue;
                    }

                    // Calculate effdis from city I to city J
                    double effdis = 1 - Math.log(fluxFraction); // Math.log is in base e. Eqn: dm,n = 1 âˆ’ ln Pm,n

                    // Store that effdis in the matrix
                    effDisMatrix.set(i, j, effdis);
                    //System.out.println(effdis);
                }
            }

        }catch (Exception ex)
        {
            System.out.println(ex);
        }
    }

    // Getters and Setters
    public static Matrix getEffDisMatrix()
    {return effDisMatrix;}

    public static Matrix getTravelMatrix()
    {return travelMatrix;}
}
